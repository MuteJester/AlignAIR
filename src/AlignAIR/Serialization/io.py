"""High-level IO helpers for saving and loading model bundles."""
from __future__ import annotations

from pathlib import Path
from typing import Tuple, Any, Dict
import json
import pickle
import logging

from .model_bundle import ModelBundleConfig, TrainingMeta, FORMAT_VERSION
from .validators import (
    ensure_required_files,
    load_config,
    verify_version_file,
    verify_fingerprint,
    validate_dataconfig_compat,
    compute_fingerprint,
)

logger = logging.getLogger(__name__)


def save_bundle(
    bundle_dir: Path,
    config: ModelBundleConfig,
    dataconfig_obj: Any,
    training_meta: TrainingMeta,
    readme_text: str | None = None,
) -> None:
    """Persist a fully described model bundle to disk.

    Parameters
    ----------
    bundle_dir : Path
        Target directory (created if missing).
    config : ModelBundleConfig
        Structural config.
    dataconfig_obj : Any
        DataConfig or MultiDataConfigContainer instance.
    weights_path : Path
        Location of already-saved weights.h5 (source).
    training_meta : TrainingMeta
        Training metadata.
    readme_text : str, optional
        Optional README content; autogenerated if None.
    """
    bundle_dir.mkdir(parents=True, exist_ok=True)

    # Write config.json
    (bundle_dir / "config.json").write_text(config.to_json())

    # Persist dataconfig pickle
    with (bundle_dir / "dataconfig.pkl").open("wb") as f:
        pickle.dump(dataconfig_obj, f, protocol=pickle.HIGHEST_PROTOCOL)

    # SavedModel is written by model.save_pretrained() into bundle_dir/saved_model
    # This IO helper does not copy weights files anymore.

    # Training meta
    (bundle_dir / "training_meta.json").write_text(training_meta.to_json())

    # VERSION file
    (bundle_dir / "VERSION").write_text(f"FORMAT_VERSION={FORMAT_VERSION}")

    # README
    if readme_text is None:
        readme_text = _default_readme(config)
    (bundle_dir / "README.md").write_text(readme_text)

    # Fingerprint
    fingerprint = compute_fingerprint(bundle_dir)
    (bundle_dir / "fingerprint.txt").write_text(fingerprint)
    logger.info("Model bundle saved at %s (fingerprint=%s)", bundle_dir, fingerprint)


def load_bundle(bundle_dir: Path) -> Tuple[ModelBundleConfig, Any, TrainingMeta]:
    """Load and validate a model bundle.

    Returns
    -------
    (ModelBundleConfig, dataconfig_obj, TrainingMeta)
    """
    ensure_required_files(bundle_dir)
    config = load_config(bundle_dir)
    verify_version_file(bundle_dir, config)
    verify_fingerprint(bundle_dir)

    # Load dataconfig
    with (bundle_dir / "dataconfig.pkl").open("rb") as f:
        dataconfig_obj = pickle.load(f)

    validate_dataconfig_compat(config, dataconfig_obj)

    # Training meta is optional for now
    training_meta_path = bundle_dir / "training_meta.json"
    if training_meta_path.exists():
        import json as _json
        meta_raw = _json.loads(training_meta_path.read_text())
        # TrainingMeta may evolve; ignore extra keys
        from .model_bundle import TrainingMeta as _TM
        known = {k: v for k, v in meta_raw.items() if k in _TM.__dataclass_fields__}
        training_meta = _TM.from_dict(known)
    else:
        from .model_bundle import TrainingMeta as _TM
        training_meta = _TM(
            epochs_trained=0,
            final_epoch=0,
            best_epoch=None,
            best_loss=None,
            final_loss=None,
            metrics_summary={},
        )

    return config, dataconfig_obj, training_meta


def _default_readme(config: ModelBundleConfig) -> str:
    return f"""# AlignAIRR Model Bundle

Format Version: {config.format_version}
Model Type: {config.model_type}
Max Sequence Length: {config.max_seq_length}

## Usage
```python
from AlignAIR.Models import {'MultiChainAlignAIR' if config.model_type=='multi_chain' else 'SingleChainAlignAIR'}
model = {'MultiChainAlignAIR' if config.model_type=='multi_chain' else 'SingleChainAlignAIR'}.from_pretrained('PATH_TO_BUNDLE')
```

## Integrity
SHA256 fingerprint stored in fingerprint.txt. Do not modify bundle contents manually.
"""


__all__ = ["save_bundle", "load_bundle"]
